/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import BN from "bn.js";
import Web3 from "web3";
import { PromiEvent, TransactionReceipt } from "web3-core/types";

import { Abi } from "./Executor.abi";
import { Executor as Web3Contract } from "./Executor.web3";
import { PayableTransactionObject, NonPayableTransactionObject } from "./types";

interface IParams {
  address: string;
  web3: Web3;
  sender?: string; // the address of sender, if undefined then web3.eth.defaultAccount used
  gasEstimationMultiplayer?: number; // if undefined then 1
}

const DEFAULT_GAS_ESTIMATION_MULTIPLAYER = 1.1; // + 10 %

export class Executor {
  native: Web3Contract;
  gasEstimationMultiplayer: number;
  web3: Web3;
  _sender: string | undefined;

  get sender(): string | undefined {
    if (this._sender) return this._sender;
    if (this.web3.defaultAccount) return this.web3.defaultAccount;
    return undefined;
  }

  protected getSenderOrFail(): string {
    const sender = this.sender;
    if (!sender) {
      throw new Error("Sender is required");
    }
    return sender;
  }

  constructor({ address, web3, sender, gasEstimationMultiplayer }: IParams) {
    this._sender = sender;
    this.native = new web3.eth.Contract(Abi, address) as any;
    this.gasEstimationMultiplayer =
      gasEstimationMultiplayer ?? DEFAULT_GAS_ESTIMATION_MULTIPLAYER;
    this.web3 = web3;
  }

  protected async estimateGas<
    K,
    T extends PayableTransactionObject<K> | NonPayableTransactionObject<K>
  >(method: T, args?: Parameters<T["estimateGas"]>) {
    const originalEstimation = await method.estimateGas(...(args ?? []));
    return new BN(originalEstimation)
      .muln(this.gasEstimationMultiplayer)
      .toString();
  }

  async _axisToken(): Promise<string> {
    return this.native.methods._axisToken().call();
  }

  async _ethToken(): Promise<string> {
    return this.native.methods._ethToken().call();
  }

  async _sUsdcToken(): Promise<string> {
    return this.native.methods._sUsdcToken().call();
  }

  async _uniswapQuoter(): Promise<string> {
    return this.native.methods._uniswapQuoter().call();
  }

  async _uniswapRouter(): Promise<string> {
    return this.native.methods._uniswapRouter().call();
  }

  async _usdcToken(): Promise<string> {
    return this.native.methods._usdcToken().call();
  }

  async addOwners(
    newOwners: string[]
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.addOwners(newOwners);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async buyLoadsFactor(): Promise<string> {
    return this.native.methods.buyLoadsFactor().call();
  }

  async owners(): Promise<string[]> {
    return this.native.methods.owners().call();
  }

  async ownersCount(): Promise<string> {
    return this.native.methods.ownersCount().call();
  }

  async payOrderFeeFixedInSusdc(): Promise<string> {
    return this.native.methods.payOrderFeeFixedInSusdc().call();
  }

  async payOrderFeePercentInSusdc(): Promise<string> {
    return this.native.methods.payOrderFeePercentInSusdc().call();
  }

  async removeOwners(
    previousOwners: string[]
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.removeOwners(previousOwners);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async swapFee(): Promise<string> {
    return this.native.methods.swapFee().call();
  }

  async swapSqrtPriceLimitX96(): Promise<string> {
    return this.native.methods.swapSqrtPriceLimitX96().call();
  }

  async isPaymentHandled(id: string | number[]): Promise<boolean> {
    return this.native.methods.isPaymentHandled(id).call();
  }

  async isPayoutHandled(id: string | number[]): Promise<boolean> {
    return this.native.methods.isPayoutHandled(id).call();
  }

  async priceInput(
    tokenIn: string,
    tokenOut: string,
    fee: number | string | BN,
    amountIn: number | string | BN,
    sqrtPriceLimitX96: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.priceInput(
      tokenIn,
      tokenOut,
      fee,
      amountIn,
      sqrtPriceLimitX96
    );
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async priceOutput(
    tokenIn: string,
    tokenOut: string,
    fee: number | string | BN,
    amountOut: number | string | BN,
    sqrtPriceLimitX96: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.priceOutput(
      tokenIn,
      tokenOut,
      fee,
      amountOut,
      sqrtPriceLimitX96
    );
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async getLoadPrice(): Promise<string> {
    return this.native.methods.getLoadPrice().call();
  }

  async handlePayment(
    id: string | number[],
    account: string,
    amount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.handlePayment(id, account, amount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async handlePayout(
    id: string | number[],
    account: string,
    amount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.handlePayout(id, account, amount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async swapSUSDCToEth(
    account: string,
    amountOut: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.swapSUSDCToEth(account, amountOut);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async swapSUSDCToAXIS(
    account: string,
    amountIn: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.swapSUSDCToAXIS(account, amountIn);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async swapAXISToSUSDC(
    account: string,
    amountIn: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.swapAXISToSUSDC(account, amountIn);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async payOrder(
    payer: string,
    order: string,
    sUsdcAmount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.payOrder(payer, order, sUsdcAmount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async buyLoads(
    account: string,
    loadsAmount: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.buyLoads(account, loadsAmount);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setLoadPrice(
    newPrice: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setLoadPrice(newPrice);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setpayOrderFeeFixedInSusdc(
    newValue: number | string | BN
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setpayOrderFeeFixedInSusdc(newValue);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }

  async setPayOrderFeePercentInSusdc(
    newValue: [number | string | BN]
  ): Promise<PromiEvent<TransactionReceipt>> {
    const method = this.native.methods.setPayOrderFeePercentInSusdc(newValue);
    return method.send({
      gas: await this.estimateGas(method),
      from: this.getSenderOrFail()
    });
  }
}
